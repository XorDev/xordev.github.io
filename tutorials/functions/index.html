<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Functions</title>
        <meta name="description" content="Shader tutorials for GameMaker Studio">
        <meta name="keywords" content="Tutorials,Shaders,GameMaker,GM,Gamedev">
        <meta name="copyright" content="Copyright 2022 GM Shaders">
        <meta name="theme-color" content="#e0ba23">
        <!-- Twitter -->
        <meta name="twitter:site" content="@XorDev">
        <meta name="twitter:title" content="GM Shaders: Functions">
        <meta name="twitter:description" content="An overview of functions and operators">
        <meta name="twitter:image" content="./thumbnail.png">
        <meta name="twitter:url" content="/">
        <!-- Open Graph -->
        <meta property="og:title" content="GM Shaders: Functions">
        <meta property="og:type" content="website">
        <meta property="og:url" content="/">
        <meta property="og:image" content="./thumbnail.png">
        <meta property="og:description" content="An overview of functions and operators">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <!-- highlightjs -->
        <link rel="stylesheet" href="../../shared/highlightjs/styles/gml.css">
        <script src="../../shared/highlightjs/highlight.pack.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
        <!-- styles -->
        <link rel="icon" href="../../shared/images/icon.png">
        <link rel="stylesheet" href="../../shared/css/style.css">
        <link rel="stylesheet" href="../../shared/css/article.css">
        <!-- javascript and fontawesome -->
        <script>const root = '../../';</script>
        <script src="../../shared/js/options.js"></script>
        <script src="../../shared/js/tutorial.js"></script>
        <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU" crossorigin="anonymous">
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-S3EKBJ8XLE"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'G-S3EKBJ8XLE');
        </script>
    </head>
    <body>
        <div class="wrapper">
            <div class="background-image hidden"></div>
            <header>
                <div class="header-buttons">
                    <div class="left">
                        <a href="../../">
                            <div class="title elm">GM Shaders</div>
                        </a>
                        <a href="../../glossary"><div class="elm">Glossary</div></a>
                        <a href="../../about"><div class="elm">About</div></a>
                        <a href="../../contact"><div class="elm">Contact</div></a>
                    </div>
                    <div class="right">
                        <div class="elm link" id="options"><i class="fas fa-cog"></i></div>
                    </div>
                </div>
            </header>
            <div class="pagecontent">
                <div class="top-info">
                    <a href="./#title"><div id="title">Functions</div></a>
                    <div class="date">1 Oct 2021</div>
                </div>
                <div class="article"><div class="wrapper">
                    <p>
                        Now that we've covered the data types, it's time to learn how to use them! Let's go over operations and functions.
                    </p>
                    <a href="./#operations"><h2 id="operations">Operations</h2></a>
                    <p>
                        One of the first things you need to know about is the operators. Thankfully, they are quite similar to GML, so this should quick to cover. All operators must both terms to use the same data type. So for <code>x + y</code>, x and y should both be floats or both be ints, and not mixed data types.
                        <ul>
                            <li>
                                <strong>Arithmetic operators:</strong> Addition (+), subtraction (-), multiplication (*) and division (/). One exception to the data type rule is that matrices and vectors can be multiplied together (as long as they have matching dimensions). Division with integers rounds down to the nearest integer as "div" does in GML.
                            </li>
                            <li>
                                <strong>Assignment operators:</strong> Increment (++), decrement (--), addition assignment (+=), subtraction assignment (-=), multiplication assignment (*=) and division assignment (/=). Incrementation simply means adding 1 to a variable and decrementation means subtracting 1, so <span title="You can put the '++' before or after the variable, depending on if you want to increment before or after it returns it's value."><code>i++</code> is equivalent to <code>i = i+1</code></span>.
                            </li>
                            <li>
                                <strong>Comparison operators:</strong> Equal-to (==), not-equal-to (!=), less-than (<), less-than or equal-to (<=), greater-than (>), greater-than or equal-to(>=). These operations always return a 1-dimensional bool being true if the condition is met, and false otherwise.
                            </li>
                            <li>
                                <strong>Condition operators:</strong> Logical AND (&&), logical OR (||), logical XOR (^^) and ternary selection  (?:). These are all supported in GML as well, but you may know them by "and", "or", and "xor". Ternary selection is like a mini if-statement. In this format: <code>(bool_condition) ? a: b</code>, if bool condition is true, it will return 'a' and if not, it returns 'b'. Helpful with writing concise code.
                            </li>
                        </ul>
                    </p>
                    <a href="./#functions"><h2 id="functions">Functions</h2></a>
                    <p>
                        Functions are a fundamental part of shaders, a bit like an extension of the operators. The built-in shader functions use inputs, called "parameters" to "return" an output from the function. This can be anything from simple math functions to getting a pixel's color from a texture. Everything beyond operators has to be done with functions.
                    </p>
                    <h3>Built-in functions</h3>
                    <p>
                        Here's a quick overview of all supported functions in GLSL ES (if want any more detail about specific functions, you can click them to view their page):
                        <ul>
                            <li>
                                <strong>Texture functions:</strong>
                                <br>
                                <a href="/glossary/?load=texture2D" target="_blank">texture2D</a>, <a href="/glossary/?load=texture2DProj" target="_blank">texture2DProj</a>,
                                <strike><a href="/glossary/?load=texture2DLod" target="_blank">texture2DLod</a></strike>, <strike><a href="/glossary/?load=texture2DProjLod" target="_blank">texture2DProjLod</a></strike>
                                <br>
                                These are the functions used to get the color and alpha of a pixel on a given sampler. The "Proj" variants are used for projecting a texture on a 3D surface (e.g. for shadow mapping) and the <span title="These are used to set the mipmap 'Level Of Detail'. A lod of 0.0 is full-resolution, 1.0 is half-resolution, 2.0 is quarter and so on.">"Lod" variants</span> are currently NOT supported in GM.
                            </li>
                            <li>
                                <strong>Common functions:</strong>
                                <br>
                                <a href="/glossary/?load=floor" target="_blank">floor</a>, <a href="/glossary/?load=ceil" target="_blank">ceil</a>, <a href="/glossary/?load=fract" target="_blank">fract</a>, <a href="/glossary/?load=mod" target="_blank">mod</a>, <a href="/glossary/?load=sign" target="_blank">sign</a>, <a href="/glossary/?load=abs" target="_blank">abs</a>, <a href="/glossary/?load=min" target="_blank">min</a>, <a href="/glossary/?load=max" target="_blank">max</a>, <a href="/glossary/?load=clamp" target="_blank">clamp</a>, <a href="/glossary/?load=mix" target="_blank">mix</a>, <a href="/glossary/?load=step" target="_blank">step</a>, <a href="/glossary/?load=smoothstep" target="_blank">smoothstep</a>
                                <br>
                                You're probably familiar with most of these functions. 'floor', 'ceil', 'sign', 'abs', 'clamp', and 'mix' (called <code>lerp</code> in GML) work exactly the same as they do in GML!
                                <br>
                                'fract', called <code>frac</code> in GML, and 'mod' both handle negatives differently, 'min' and 'max' are limited to only two arguments each, leaving 'step' and 'smoothstep' as the only unfamiliar functions. I won't summarize them here so I encourage you to check out those pages.
                            </li>
                            <li>
                                <strong>Math functions:</strong>
                                <br>
                                <a href="/glossary/?load=pow" target="_blank">pow</a>, <a href="/glossary/?load=sqrt" target="_blank">sqrt</a>, <a href="/glossary/?load=inversesqrt" target="_blank">inversesqrt</a>, <a href="/glossary/?load=exp" target="_blank">exp</a>, <a href="/glossary/?load=exp2" target="_blank">exp2</a>, <a href="/glossary/?load=log" target="_blank">log</a>, <a href="/glossary/?load=log2" target="_blank">log2</a>
                                <br>
                                'sqrt' works the same as in GML, pow is the equivalent to the GML <code>power</code>, 'inversesqrt' is the reciprocal of the square root, the "exp" functions are exponential functions and the "log" are logarithms with different bases (The Natural Number and 2).
                            </li>
                            <li>
                                <strong>Vector functions:</strong>
                                <br>
                                <a href="/glossary/?load=length" target="_blank">length</a>, <a href="/glossary/?load=distance" target="_blank">distance</a>, <a href="/glossary/?load=normalize" target="_blank">normalize</a>, <a href="/glossary/?load=dot" target="_blank">dot</a>, <a href="/glossary/?load=cross" target="_blank">cross</a>, <a href="/glossary/?load=reflect" target="_blank">reflect</a>, <a href="/glossary/?load=refract" target="_blank">refract</a>, <a href="/glossary/?load=faceforward" target="_blank">faceforward</a>, <a href="/glossary/?load=matrixCompMult" target="_blank">matrixCompMult</a>
                                <br>
                                'length' and 'distance' find the length of a vector and distance between two vectors, 'normalize' divides a vector by its length, 'dot' and 'cross' are for dot and cross products which you may or may not be familiar with. The rest of them are more complicated and so I encourage reading later.
                            </li>
                            <li>
                                <strong>Trigonometry functions:</strong>
                                <br> <a href="/glossary/?load=radians" target="_blank">radians</a>, <a href="/glossary/?load=degrees" target="_blank">degrees</a>, <a href="/glossary/?load=sin" target="_blank">sin</a>, <a href="/glossary/?load=cos" target="_blank">cos</a>, <a href="/glossary/?load=tan" target="_blank">tan</a>, <a href="/glossary/?load=asin" target="_blank">asin</a>, <a href="/glossary/?load=acos" target="_blank">acos</a>, <a href="/glossary/?load=atan" target="_blank">atan</a>
                                <br>
                                'radians' (<code>degtorad</code> in GML) converts angles from degrees to radians and 'degrees' (<code>radtodeg</code> in GML) converts radians to degrees. 'cos', 'sin', 'tan' function just like in GML, 'acos', 'asin', 'atan' function just like the "arc" equivalents in GML.
                            </li>
                            <li>
                                <strong>Boolean functions:</strong>
                                <br> <a href="/glossary/?load=equal" target="_blank">equal</a>, <a href="/glossary/?load=notEqual" target="_blank">notEqual</a>, <a href="/glossary/?load=lessThan" target="_blank">lessThan</a>, <a href="/glossary/?load=lessThanEqual" target="_blank">lessThanEqual</a>, <a href="/glossary/?load=greaterThan" target="_blank">greaterThan</a>, <a href="/glossary/?load=greaterThanEqual" target="_blank">greaterThanEqual</a>, <a href="/glossary/?load=any" target="_blank">any</a>, <a href="/glossary/?load=all" target="_blank">all</a>, <a href="/glossary/?load=not" target="_blank">not</a>
                                <br>
                                'equal', 'notEqual', 'lessThan', 'lessThanEqual', 'greaterThan' and 'greaterThanEqual' all return bools (or bvecs) being <span title="And with vectors, it checks the condition for each component of the vectors.">true if the condition is met</span> or false if not. `all` returns true if all components of a bvec are true, 'any' returns true if any components of a bvec are true and `not` simply <span title="Turning true to false and false to true.">negates</span> all components of a bool or bvec.
                            </li>
                        </ul>
                    </p>
                    <a href="./#matrices"><h2 id="matrices">Matrices</h2></a>
                    <p>
                        Now that you have an overview of the operations and functions, it's much easier to explain matrices. So we know from the <a href="/tutorials/datatypes/#dimensions" target="_blank">last tutorial</a> that mat2 contains 4 (2x2) components and that the order of multiplication matters, but now I can show you why. First, let's consider these two cases:
                        <pre><code class="glsl">//Remember, a matrix is like an array of vectors rather than a larger vector.
mat2 matrix = mat2(2, 3, 4, 5); //First row is 2 and 3, second row: 4 and 5.

vec2 A = vec2(0, 1) * matrix; //Computed as vec2(3, 5)
vec2 B = matrix * vec2(0, 1); //Computed as vec2(4, 5)</code></pre>
                        To perform a vector-matrix multiplication, you can generalize with this forumla for each component 'i': <pre><code class="glsl">new_vector[i] = vector[0] * matrix[0][i] + ... + vector[n] * matrix[n][i];</code></pre>
                        So in the example above, we are essentially calculating: <code class="glsl">A = vec2(0*2 + 1*3, 0*4 + 1*5)</code>.
                        If you swap the order putting the matrix first, then you swap the matrix rows for columns and columns for rows and you get this: <code class="glsl">B = vec2(0*2 + 1*4, 0*3 + 1*5)</code>.<br>To make this a little easier to remember, you can also think of this as a separate <a href="/glossary/?load=dot" target="_blank">dot-product</a> for each component: <code class="glsl">new_vector[i] = dot(vector, matrix[i]);</code>
                        <br>
                        Alright, that's enough math for now! Feel free to revisit this if you ever need a refresher!
                    </p>
                    <a href="./#logic"><h2 id="logic">Logic and loop statements</h2></a>
                    <p>
                        Logic statements are a crucial part of programming languages and GLSL ES is no exception. You're probably already familiar with these so I'll be brief and just clarify the syntax differences. Here is a list of those statements:
                        <br>
                        <ul>
                            <li>
                                <strong>if:</strong>
                                <br>
                                Shaders syntax is more strict than in GML so your if statement must be in this format:
                                <pre><code class="glsl">if (bool_condition) //example: a == b
{
    do_something();
}</code></pre>
                                Specifically, your condition must be a bool (unlike in GML) and MUST be placed in parentheses. I recommend using curly brackets at the start and end of the conditional code for ease of reading, but it's not required in one-liners.
                            </li>
                            <li>
                                <strong>for:</strong>
                                <br>
                                For statements loop code inside the brackets (or the next line) until a condition is false. They must have at least a condition in this format:
                                <pre><code class="glsl">for(; bool_condition; ) //example: i > 10
{
    do_something();
}
</code></pre>
                            But more commonly you'll see something like this:
                            <pre><code class="glsl">for(int i = 0; i<10; i++)</code></pre>
                            So you don't have to initialize a variable or increment inside the for-loop, but you must have two semicolons to separate the condition.
                            </li>
                            <li>
                                <strong>while:</strong>
                                <br>
                                While statements loop through the code in the brackets (or the next line) until a condition is false. Make sure an end condition is met or it will loop until it crashes.
                                <pre><code class="glsl">while (bool_condition)
{
    do_something();
}</code></pre>
                            </li>
                            <li>
                                <strong>do-while:</strong>
                                <br>
                                Do-while statements loops code inside the brackets just like <code>while</code>, except the condition is checked after the first iteration. This means it will always do at least one loop. This is the standard format:
                                <pre><code class="glsl">do
{
    do_something();
}
while(bool_condition);</code></pre>
                            </li>
                        </ul>
                        <h3>Loop control</h3>
                        There are <span title="You may also break the loop with 'return' and 'discard', but those have additional properties.">two main ways</span> to stop a loop. Break and continue:
                        <ul>
                            <li>
                                <strong>break:</strong>
                                <br>
                                Aborts the loop, skipping everything in the loop after it. Put this at the bottom of your loop if you want the code to execute before aborting!
                            </li>
                            <li>
                                <strong>continue:</strong>
                                <br>
                                Skips the rest of the loop iteration and jumps to the next iteration. Putting this at the end of a loop will have no effect.
                            </li>
                        </ul>
                        'break' is often used when additional iterations are unnecessary and in some cases can speed up performance significantly.
                    </p>
                    <a href="./#custom"><h2 id="custom">Custom functions</h2></a>
                    <p>
                        Custom functions are another useful feature for organizing your code. Here's a simple example function:
<pre><code>vec4 tex(vec2 coordinates)
{
    return texture2D(gm_BaseTexture, coordinates);
}</code></pre>
                        When called, this outputs a (vec4) pixel color from the base-texture at the given texture coordinates. This shows you set the output datatype before the function name and you can add parameters to your functions inside the parentheses.
                        <br>
                        Along with defining a parameter's datatype, you can also set parameter qualifiers:
                        <ul>
                            <li>
                                <strong>in:</strong>
                                <br>
                                This is the default qualifier for parameters when none is specified. It simply inputs a value from called function as expected. It can be thought of as a read-only variable.
                            </li>
                            <li>
                                <strong>out:</strong>
                                <br>
                                This is for an output variable rather than an input. That means you need to set its value inside the function. This can be thought of as a write-only variable.
                            </li>
                            <li>
                                <strong>inout:</strong>
                                <br>
                                This can be used as an input and an output. In other words, it's a read-and-write variable.
                            </li>
                        </ul>
                        Here's an example:
<pre><code>vec4 vignette_tex(in vec2 coordinates, out float vignette)
{
    vec4 tex = texture2D(gm_BaseTexture, coordinates);
    vignette = (1.-length(coordinates-.5));
    return tex*vignette;
}</code></pre>
                        Here we have an input (texture coordinates) and an output (vignette brightness) along with a vec4 return. Sometimes you need to output multiple values and <code>out</code> is a way to do that!
                        <br>
                        It's also important to understand variable 'scope' to avoid naming conflicts. Basically, if you define a variable inside brackets (e.g. custom functions, if-statements, or loops), it will only be local to that scope. That means your functions can all use variables with the same name as long as it doesn't conflict with a global variable (outside of functions). It's a lot like global and local variables (being limited to specific instances) in GML.
                    </p>
                    <h3>The main function</h3>
                    <p>
                        The main function is a bit of unusual because it doesn't have any parameters, doesn't return anything, and is the one custom function required in every single shader! Instead of parameters, you just have to work off of the built-in "gl_" and "gm_" variables, attributes (vertex shader), and varyings (fragment shader).
                        <ul>
                            <li>
                                <strong>Vertex shader:</strong>
                                <br>
                                In the vertex shader, you must set <code>gl_Position</code>, which is the vertex position in "projection-space". More on that later, but for now, you just need to know that it's the vertex position, usually transformed by the <code>gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION]</code>. Here you can set the vertex position however like, for example, if you want to flip the y-axis, you can do this:
                                <pre><code class="glsl">//Vertex position with an inverted y-axis.
vec4 inverted_pos = vec4(in_Position.x, -in_Position.y, in_Position.z, 1.0);
//Set the vertex position.
gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * inverted_pos;
</code></pre>
                                You may have noticed the "inverted_pos" is a vec4. The W component is used with the transformation matrices and should always be 1.0. This will make sense in the next tutorial so don't worry about it for now.
                                <br>
                                The main function is also where you set the values for 'varying' variables. Most shaders pass the color and texture coordinate values from the attributes to the fragment shader via varyings. Some shaders also pass the vertex position or normals, but you can pass anything you want. The general rule is, if it can be computed in the vertex shader, do that because it's faster to do one calculation per-triangle than one per-pixel!
                            </li>
                            <li>
                                <strong>Fragment shader:</strong>
                                <br>
                                In the fragment shader, you must set <code>gl_FragColor</code>, which determines the output <span title="A fragment is the portion of a sprite/primitive inside a pixel. That means you could have multiple fragments on different depth layers, but always only one resulting pixel at that point.">fragment/pixel</span> color. For example, the default shader simply outputs the texture color and alpha.
                                <br>
                                gl_FragColor's channels are "normalized", meaning the acceptable range is 0 to 1 (unlike GML's 0-255). This is because the shader doesn't "know" how bits are needed for each channel. Currently, GM only supports 8-bit (0-255) RGBA textures, but perhaps someday we'll get other options.
                                <br>
                                Another useful statement is called "discard". When called, it will completely skip rendering the fragment; used for alpha testing, and more. Here's an example:
                                <pre><code class="glsl">vec4 tex = texture2D(gm_BaseTexture, v_vTexcoord);
//Discard all fragments that are less than 50% alpha.
if (tex.a<.5) discard;
</code></pre>
                                Note: You should avoid using discard if it's possible to do so because it is <span title="Shaders use various graphics acceleration techniques to quickly approximate fragment depth and visibility. Using discard makes this acceleration impossible, and it's very slow on mobile devices!">very slow on some platforms</span>.
                                <br>
                                And that pretty much covers the fragment shader!
                            </li>
                        </ul>
                    </p>
                    <a href="./#summary"><h2 id="summary">Summary</h2></a>
                    <p>
                        That was a lot to cover so don't worry if you don't understand some parts! The purpose of these tutorials is to help provide a solid foundation that you can refer to when you need to. If you have a decent grasp of operations and functions, you can begin experimenting. As you become more comfortable with shaders, you'll learn how to write code more efficiently and clearly.
                        <br>
                        At this point you have all you need to begin writing your own shaders, however the next tutorial will explain tips and tricks I've learned to help you launch into it! Congrats, you've almost completed!
                    </p>
                </div>
              </div>
            </div>
            <div class="navigate-end"></div>
            <footer><div class="left">&copy; GM Shaders 2022</div><div class="right"> Website developed by <a target="_blank" href="https://TonyStr.net">TonyStr</a></div></footer>
        </div>
        <script>initialize();</script>
    </body>
</html>
