<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>GM Shaders Glossary</title>
        <meta name="description" content="Shader tutorials for GameMaker">
        <meta name="keywords" content="Tutorials,Shaders,GameMaker,GM,Gamedev">
        <meta name="copyright" content="Copyright 2024 GM Shaders">
        <meta name="theme-color" content="#e0ba23">
        <!-- Twitter -->
        <meta name="twitter:site" content="@XorDev">
        <meta name="twitter:title" content="GM Shaders">
        <meta name="twitter:description" content="Shader tutorials for GameMaker">
        <meta name="twitter:image" content="../../shared/images/icon.png">
        <meta name="twitter:url" content="/">
        <!-- Open Graph -->
        <meta property="og:title" content="GM Shaders">
        <meta property="og:type" content="website">
        <meta property="og:url" content="/">
        <meta property="og:image" content="../../shared/images/icon.png">
        <meta property="og:description" content="Shader tutorials for GameMaker">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <!-- highlightjs -->
        <link rel="stylesheet" href="../shared/highlightjs/styles/atom-one-dark.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>

        <link rel="icon" href="../../shared/images/icon.png">
        <link rel="stylesheet" href="../shared/css/style.css">
        <link rel="stylesheet" href="../shared/css/glossary.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.6.0/css/all.css" integrity="sha384-YUkLDKfIHKKPXyTxOqW7iOjFJSl8vAO0X3DgGqpRKHu6R4VKlAGZNr6PIQgTUZYQ" crossorigin="anonymous">
        <script>const root="../";</script>
        <script src="../shared/js/options.js"></script>
        <script src="../shared/js/glossary.js"></script>
    </head>
    <body>
        <div class="wrapper">
            <div class="background-image hidden grid"></div>
            <header>
                <div class="header-buttons">
                    <div class="left">
                        <a href="../">
                            <div class="title elm">GM Shaders</div>
                        </a>
                        <a href="../glossary"><div class="elm current">Glossary</div></a>
                        <a href="../about"><div class="elm">About</div></a>
                        <a href="../contact"><div class="elm">Contact</div></a>
                    </div>
                    <div class="right">
                        <div class="elm link" id="options"><i class="fas fa-cog"></i></div>
                    </div>
                </div>
            </header>
            <div class="searchbar">
                <div class="bar">
                    <input id="search_docs" type="search" placeholder="Search">
                    <div class="return"><i class="fas fa-times"></i></div>
                    <div class="message"></div>
                </div>
                <div class="results"></div>
            </div>
            <div id="docs"><div id="Attributes" class="type-title"><span>Attributes</span></div><div class="Attributes doc" id="in_Colour">
                    <div class="link" onclick="creacopURL(this, 'in_Colour')">Copy link</div>
                    <div class="content">
                        <div class="name">in_Colour</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>attribute vec4 in_Colour;</code></pre></span>
                    </div><div class="returns ">
                        <div class="title">Returns:</div>
                        vec4, vertex color and alpha
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Vertex color and alpha. When applied to sprite this will be the image_blend and image_alpha, for most other draw_* functions it will be the <span class="inline-hljs"><pre><code>draw_set_color</code></pre></span> and <span class="inline-hljs"><pre><code>draw_set_alpha</code></pre></span> and for vertex buffers/primitives, the color you set for each vertex. <br><br>If you're using a custom vertex format that includes multiple colors, just use 'in_Colour0', 'in_Colour1', etc.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Pass a varying 'v_vColor' to the fragment shader.
v_vColour = in_Colour;</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Attributes doc" id="in_Position">
                    <div class="link" onclick="creacopURL(this, 'in_Position')">Copy link</div>
                    <div class="content">
                        <div class="name">in_Position</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>attribute vec3 in_Position;</code></pre></span>
                    </div><div class="returns ">
                        <div class="title">Returns:</div>
                        vec3, vertex position
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Vertex position in model-space. Most GML draw_* functions (e.g. draw_sprite) build their vertex buffer in world space so that they don't need the world matrix. Keep this in mind when you're using your own vertex buffer!
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Output the projection-space vertex position.
gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * vec4(in_Position,1.);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Attributes doc" id="in_TextureCoord">
                    <div class="link" onclick="creacopURL(this, 'in_TextureCoord')">Copy link</div>
                    <div class="content">
                        <div class="name">in_TextureCoord</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>attribute vec2 in_TextureCoord;</code></pre></span>
                    </div><div class="returns ">
                        <div class="title">Returns:</div>
                        vec2, texture coordinates
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        The texture coordinates (or uvs) range from 0 to 1 across the texture page. That means that surfaces and sprites that are on their own texture page will have normalized uvs, which can be very useful. However for other sprites you can always pass in the sprite uvs (from <span class="inline-hljs"><pre><code>sprite_get_uvs</code></pre></span>) and normalize them yourself. <br><br>In GM, you're encouraged to use texture coordinates for any extra attributes (e.g, tangents, bone weights, etc) so any other attribute name will be interpreted as a 'texture coordinate' attribute (e.g in_Tangent, in_Bitangent, etc will work fine).
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Pass a varying 'v_vTexcoord' to the fragment shader.
v_vTexcoord = in_Texcoord;</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Attributes doc" id="in_Normal">
                    <div class="link" onclick="creacopURL(this, 'in_Normal')">Copy link</div>
                    <div class="content">
                        <div class="name">in_Normal</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>attribute vec3 in_Normal;</code></pre></span>
                    </div><div class="returns ">
                        <div class="title">Returns:</div>
                        vec3, vertex normal
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Vertex geometry normal. This is only used in some custom vertex formats, with 3D models that need geometry normals (usually for lighting). A normal is a vector perpendicular to the model's surface. Make sure the normal vectors have a length of 1.0.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Compute diffuse lighting using a light direction vector
float diffuse = max(dot(in_Normal, light_dir), 0.0);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div id="Functions" class="type-title"><span>Functions</span></div><div class="Functions doc" id="texture2D">
                    <div class="link" onclick="creacopURL(this, 'texture2D')">Copy link</div>
                    <div class="content">
                        <div class="name">texture2D(texture, coordinates, [bias])</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>texture2D(sampler2D, vec2, [float])</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">texture</div><div class="desc block">
                        <div class="title">Description:</div>
                        ID of the texture to sample.
                    </div></li><li><div class="name">coordinates</div><div class="desc block">
                        <div class="title">Description:</div>
                        x and y texture coordinates of the pixel to sample.
                    </div></li><li><div class="name">bias</div><div class="desc block">
                        <div class="title">Description:</div>
                        Optional mipmap bias.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        vec4, texel color and alpha
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Samples the texture at the given texture coordinates for color and alpha. Texture coordinates are between 0 to 1 and they represent a pixel position on the sampler's texture page. Each texture (or sprite) has its own set of texture coordinates within the texture page, so sometimes you may need to convert from one set of coordinates to another. You can use the GML <span class="inline-hljs"><pre><code>sprite_get_uvs</code></pre></span> to get the set of coordinates, which can be passed into the shader via uniforms. Surfaces or sprites with the 'Separate Texture Page' box ticked will always have a range of 0 to 1 so they are easier to deal with.<br>Also, the sampled pixel will be filtered by GM (no interpolation, linear interpolation or mipmapping) which is why we call this a 'texel'.<br>With mipmapping enabled, you can add a bias to the LOD level (this does not work with surfaces!). Using a positive bias will reduce the resolution to give it a softer look and a negative bias will make higher resolution if possible.
                    </div><div class="examples ">
                            <div class="title">Examples:</div>
                            <ul><li><pre><code>texture2D(gm_BaseTexture, v_vTexcoord);</pre></code></li><li><pre><code>//Using the sampler 'uni_diffuse' and 1.0 bias (half resolution with mipmapping).
texture2D(uni_diffuse, v_vTexcoord, 1.0);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="texture2DLod">
                    <div class="link" onclick="creacopURL(this, 'texture2DLod')">Copy link</div>
                    <div class="content">
                        <div class="name"><strike>texture2DLod</strike>(texture, coordinates, lod)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>texture2DLod(sampler2D, vec2, float)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">texture</div><div class="desc block">
                        <div class="title">Description:</div>
                        ID of the texture to sample.
                    </div></li><li><div class="name">coordinates</div><div class="desc block">
                        <div class="title">Description:</div>
                        x and y texture coordinates of the pixel to sample.
                    </div></li><li><div class="name">lod</div><div class="desc block">
                        <div class="title">Description:</div>
                        Overwrites mipmap LOD.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        vec4, texel color and alpha
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Currently not supported in GM!<br><br>Samples the texture at the given texture coordinates for color and alpha. Texture coordinates are between 0 to 1 and they represent a pixel position on the sampler's texture page. Each texture (or sprite) has its own set of texture coordinates within the texture page, so sometimes you may need to convert from one set of coordinates to another. You can use the GML <span class="inline-hljs"><pre><code>sprite_get_uvs</code></pre></span> to get the set of coordinates, which can be passed into the shader via uniforms. Surfaces or sprites with the 'Separate Texture Page' box ticked will always have a range of 0 to 1 so they are easier to deal with.<br>It's worth noting that the sampled pixel will be filtered by GM (no interpolation, linear interpolation or mipmapping, etc) which is why we call this a 'texel'.<br>This works like  <a href='/glossary/?load=texture2D' target='_blank'>texture2D'</a> except it overwrites the automatic LOD level with the LOD you specify. If mipmapping is disabled, it will output the same result as texture2D would.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Force half resolution with mipmapping.
texture2DLod(gm_BaseTexture, v_vTexcoord, 1.0);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="texture2DProj">
                    <div class="link" onclick="creacopURL(this, 'texture2DProj')">Copy link</div>
                    <div class="content">
                        <div class="name">texture2DProj(texture, coordinates, [bias])</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>texture2DProj(sampler2D, vec3/vec4, [float])</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">texture</div><div class="desc block">
                        <div class="title">Description:</div>
                        ID of the texture to sample.
                    </div></li><li><div class="name">coordinates</div><div class="desc block">
                        <div class="title">Description:</div>
                        x, y and z for projecting texture coordinates.
                    </div></li><li><div class="name">bias</div><div class="desc block">
                        <div class="title">Description:</div>
                        Optional mipmap bias.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        vec4, texel color and alpha
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        texture2DProj is like  <a href='/glossary/?load=texture2D' target='_blank'>texture2D'</a> except it computes it's texture coordinates from the x and y coordinates divided by the last component (z component for a vec3 or w for a vec4); Useful in 3D when you need to project a 2D texture onto 3D geometry. Then it samples the texture at the given texture coordinates for color and alpha. Texture coordinates are between 0 to 1 and they represent a pixel position on the sampler's texture page. Each texture (or sprite) has its own set of texture coordinates within the texture page, so sometimes you may need to convert from one set of coordinates to another. You can use the GML <span class="inline-hljs"><pre><code>sprite_get_uvs</code></pre></span> to get the set of coordinates, which can be passed into the shader via uniforms. Surfaces or sprites with the 'Separate Texture Page' box ticked will always have a range of 0 to 1, so they are easier to deal with.<br>Also, the sampled pixel will be filtered by GM (no interpolation, linear interpolation or mipmapping) which is why we call this a 'texel'.<br>With mipmapping, you can add a bias to the LOD level (this does not work with surfaces!). Using a positive bias will reduce the resolution to give it a softer look and a negative bias will make higher resolution if possible.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Project a texture using frag coordinates.
texture2DProj(gm_BaseTexture, gl_FragCoord.xyz);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="texture2DProjLod">
                    <div class="link" onclick="creacopURL(this, 'texture2DProjLod')">Copy link</div>
                    <div class="content">
                        <div class="name"><strike>texture2DProjLod</strike>(texture, coordinates, lod)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>texture2DProjLod(sampler2D, vec3/vec4, float)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">texture</div><div class="desc block">
                        <div class="title">Description:</div>
                        ID of the texture to sample.
                    </div></li><li><div class="name">coordinates</div><div class="desc block">
                        <div class="title">Description:</div>
                        x, y and z for projecting texture coordinates.
                    </div></li><li><div class="name">lod</div><div class="desc block">
                        <div class="title">Description:</div>
                        Overwrites mipmap LOD.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        vec4, texel color and alpha
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Currently not supported in GM!<br><br>texture2DProjLod is like  <a href='/glossary/?load=texture2DLod' target='_blank'>texture2DLod</a> except it computes it's texture coordinates from the x and y coordinates divided by the last component (z component for a vec3 or w for a vec4); Useful in 3D when you need to project a 2D texture onto 3D geometry. Then it samples the texture at the given texture coordinates for color and alpha. Texture coordinates are between 0 to 1 and they represent a pixel position on the sampler's texture page. Each texture (or sprite) has its own set of texture coordinates within the texture page, so sometimes you may need to convert from one set of coordinates to another. You can use the GML <span class="inline-hljs"><pre><code>sprite_get_uvs</code></pre></span> to get the set of coordinates, which can be passed into the shader via uniforms. Surfaces or sprites with the 'Separate Texture Page' box ticked will always have a range of 0 to 1, so they are easier to deal with.<br>Also, the sampled pixel will be filtered by GM (no interpolation, linear interpolation or mipmapping) which is why we call this a 'texel'.<br>With mipmapping, it overwrites the automatic LOD level with the specific LOD you want. If mipmapping is disabled, it will output the same result as  <a href='/glossary/?load=texture2DProj' target='_blank'>texture2DProj</a> would.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Project a texture at half resolution (using mipmapping).
texture2DProjLod(gm_BaseTexture, gl_FragCoord.xyz, 1.0);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="floor">
                    <div class="link" onclick="creacopURL(this, 'floor')">Copy link</div>
                    <div class="content">
                        <div class="name">floor(x)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>floor(float/vec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">x</div><div class="desc block">
                        <div class="title">Description:</div>
                        The input value.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        float/vec, x rounded down
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        <span class="inline-hljs"><pre><code>floor</code></pre></span> is like in GML, it returns 'x' rounded down to the nearest whole number. So <span class="inline-hljs"><pre><code>floor(1.5)</code></pre></span> returns 1.0
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>float two = floor(2.5);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="ceil">
                    <div class="link" onclick="creacopURL(this, 'ceil')">Copy link</div>
                    <div class="content">
                        <div class="name">ceil(x)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>ceil(float/vec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">x</div><div class="desc block">
                        <div class="title">Description:</div>
                        The input value.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        float/vec, x rounded up
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        <span class="inline-hljs"><pre><code>ceil</code></pre></span> is like in GML, it returns 'x' rounded up to the nearest whole number. So <span class="inline-hljs"><pre><code>ceil(1.5)</code></pre></span> returns 2.0
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>float three = ceil(2.5);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="fract">
                    <div class="link" onclick="creacopURL(this, 'fract')">Copy link</div>
                    <div class="content">
                        <div class="name">fract(x)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>fract(float/vec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">x</div><div class="desc block">
                        <div class="title">Description:</div>
                        The input value.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        float/vec, fractional part of x
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        <span class="inline-hljs"><pre><code>fract</code></pre></span> is similar to <span class="inline-hljs"><pre><code>frac</code></pre></span> in GML with the same results for positive <span class="inline-hljs"><pre><code>x</code></pre></span> (not with negatives). This returns just the fractional part of 'x', removing the whole number part. Internally, it's computed as <span class="inline-hljs"><pre><code>x - floor(x)</code></pre></span>, so <span class="inline-hljs"><pre><code>fract(3.14)</code></pre></span> returns 0.14.<br><br>Note: the GML function relates with the shader function like so: <span class="inline-hljs"><pre><code>frac(x) = fract(abs(x)) * sign(x)</code></pre></span>
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>float half = fract(2.5);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="mod">
                    <div class="link" onclick="creacopURL(this, 'mod')">Copy link</div>
                    <div class="content">
                        <div class="name">mod(x, y)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>mod(float/vec, float/vec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">x</div><div class="desc block">
                        <div class="title">Description:</div>
                        The input value.
                    </div></li><li><div class="name">y</div><div class="desc block">
                        <div class="title">Description:</div>
                        The divisor.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        float/vec, fractional part of x
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        <span class="inline-hljs"><pre><code>mod</code></pre></span> is similar to the GML modulo operator (also called <span class="inline-hljs"><pre><code>mod</code></pre></span>), giving the same results for positive <span class="inline-hljs"><pre><code>x</code></pre></span> (not with negatives). This returns the remainder of <span class="inline-hljs"><pre><code>x</code></pre></span> divided by <span class="inline-hljs"><pre><code>y</code></pre></span> which is computed as <span class="inline-hljs"><pre><code>x - floor(x/y)*y</code></pre></span>.<br><br>Note: the GML operator relates with the shader function like so: <span class="inline-hljs"><pre><code>x mod y = mod(abs(x),y) * sign(x)</code></pre></span>
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>float two = mod(7.0,5.0);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="sign">
                    <div class="link" onclick="creacopURL(this, 'sign')">Copy link</div>
                    <div class="content">
                        <div class="name">sign(x)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>sign(float/vec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">x</div><div class="desc block">
                        <div class="title">Description:</div>
                        The input value.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        float/vec, sign of x
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        <span class="inline-hljs"><pre><code>sign</code></pre></span> is like in GML, it returns the sign for each component of <span class="inline-hljs"><pre><code>x</code></pre></span>. So if x is positive, it returns 1.0, if x is negative it returns -1.0 and 0.0 if x equals zero.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>float one = sign(10.);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="abs">
                    <div class="link" onclick="creacopURL(this, 'abs')">Copy link</div>
                    <div class="content">
                        <div class="name">abs(x)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>abs(float/vec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">x</div><div class="desc block">
                        <div class="title">Description:</div>
                        The input value.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        float/vec, x as a positive
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        <span class="inline-hljs"><pre><code>abs</code></pre></span> is like in GML, it returns 'x' as a positive number. So if 'x' is negative 'abs' returns '-x' so the result is always positive (or 0).
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>float five = abs(-5.0);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="min">
                    <div class="link" onclick="creacopURL(this, 'min')">Copy link</div>
                    <div class="content">
                        <div class="name">min(x, y)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>min(float/vec, float/vec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">x</div><div class="desc block">
                        <div class="title">Description:</div>
                        The first input value.
                    </div></li><li><div class="name">y</div><div class="desc block">
                        <div class="title">Description:</div>
                        The second input value.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        float/vec, the lesser of x and y
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        <span class="inline-hljs"><pre><code>min</code></pre></span> is like in GML (except limited to 2 input arguments), returns the lesser of the two values. So it will return 'x' if 'x' is less than 'y' and otherwise it returns 'y'.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>float one = min(1.0, 4.0);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="max">
                    <div class="link" onclick="creacopURL(this, 'max')">Copy link</div>
                    <div class="content">
                        <div class="name">max(x, y)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>max(float/vec, float/vec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">x</div><div class="desc block">
                        <div class="title">Description:</div>
                        The first input value.
                    </div></li><li><div class="name">y</div><div class="desc block">
                        <div class="title">Description:</div>
                        The second input value.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        float/vec, the greater of x and y
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        <span class="inline-hljs"><pre><code>max</code></pre></span> is like in GML (except limited to 2 input arguments), returns the greater of the two values. So it will return 'x' if 'x' is greater than 'y' and otherwise it returns 'y'.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>float four = max(1.0, 4.0);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="clamp">
                    <div class="link" onclick="creacopURL(this, 'clamp')">Copy link</div>
                    <div class="content">
                        <div class="name">clamp(x, min, max)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>clamp(float/vec, float/vec, float/vec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">x</div><div class="desc block">
                        <div class="title">Description:</div>
                        The input value.
                    </div></li><li><div class="name">min</div><div class="desc block">
                        <div class="title">Description:</div>
                        The minimum value.
                    </div></li><li><div class="name">max</div><div class="desc block">
                        <div class="title">Description:</div>
                        The maximum value.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        float/vec, x between min and max
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        <span class="inline-hljs"><pre><code>clamp</code></pre></span> is just like in GML, returning 'x' if 'x' is between 'min' and 'max'. If 'x' is less than 'min' it returns 'min' and if 'x' is greater than 'max' it returns 'max', effectively clamp 'x' to the 'min-max' range.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>float five = abs(-5.0);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="mix">
                    <div class="link" onclick="creacopURL(this, 'mix')">Copy link</div>
                    <div class="content">
                        <div class="name">mix(x1, x2, amt)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>mix(float/vec, float/vec, float/vec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">x1</div><div class="desc block">
                        <div class="title">Description:</div>
                        The first (or source) value.
                    </div></li><li><div class="name">x2</div><div class="desc block">
                        <div class="title">Description:</div>
                        The second (or destination) value.
                    </div></li><li><div class="name">amt</div><div class="desc block">
                        <div class="title">Description:</div>
                        The amount to intepolate.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        float/vec, mixture of a and b
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        mix is like the GML <span class="inline-hljs"><pre><code>lerp</code></pre></span>, it linearly interpolates between 'x1' and 'x2' by the amount 'amt'. So <span class="inline-hljs"><pre><code>mix(x1,x2,0.0)</code></pre></span> would equal 'x1' and <span class="inline-hljs"><pre><code>mix(x1,x2,1.0)</code></pre></span> equals 'x2'. When 'amt' is anything between 0 and 1, the result will be somewhere between x1 and x2.<br>Mix is computed as: <span class="inline-hljs"><pre><code>x1 + (x2-x1)*amt</code></pre></span> so 'x1' and 'x2' must have the same number of components however 'amt' can be a float or a vector.
                    </div><div class="examples ">
                            <div class="title">Examples:</div>
                            <ul><li><pre><code>//Mix between the source color and destination color, by 'factor' (float or vec3)
vec3 col = mix(src, dst, factor);</pre></code></li><li><pre><code>//Get the source's red and green channels and the destination's blue channel.
vec3 col = mix(src, dst, vec3(0,0,1));</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="step">
                    <div class="link" onclick="creacopURL(this, 'step')">Copy link</div>
                    <div class="content">
                        <div class="name">step(edge, x)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>step(float/vec, float/vec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">edge</div><div class="desc block">
                        <div class="title">Description:</div>
                        The edge value for comparing.
                    </div></li><li><div class="name">x</div><div class="desc block">
                        <div class="title">Description:</div>
                        The input value.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        float/vec, zero or one
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Returns 0.0 when 'x' is less than 'edge' and 1.0 when it is not. This sometimes can be used as a substitute for an if statement.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Set the alpha to 0.0 if 'color.a' is less-than 0.5:
color.a = step(0.5, color.a);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="smoothstep">
                    <div class="link" onclick="creacopURL(this, 'smoothstep')">Copy link</div>
                    <div class="content">
                        <div class="name">smoothstep(edge0, edge1, x)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>smoothstep(float/vec, float/vec, float/vec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">edge0</div><div class="desc block">
                        <div class="title">Description:</div>
                        The starting edge.
                    </div></li><li><div class="name">edge1</div><div class="desc block">
                        <div class="title">Description:</div>
                        The ending edge.
                    </div></li><li><div class="name">x</div><div class="desc block">
                        <div class="title">Description:</div>
                        The input value.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        float/vec, between zero and one
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Returns 0.0 if 'x' is equal to 'edge0' and 1.0 if 'x' is equal to 'edge1'. Any value of 'x' in between will be smoothly blended between zero and one, making it quite useful for gradients. <div class='image'><img src='./smoothstep.png'></img></div> If you want to take a value from any range and gaurantee a result between 0 and 1, this is probably what you're looking for. You can then add/multiply as necessary to map it to any other range.<br><br>Note: This gradient is not linear, but rather it tapers off at both ends. If you're curious, here's how it is computed internally:<br><span class="inline-hljs"><pre><code>float range = (x-edge0)/(edge1-edge0); //Map to 0-1 range</code></pre></span><br><span class="inline-hljs"><pre><code>float y = clamp(range, 0.0, 1.0); //Clamp to 0-1</code></pre></span><br><span class="inline-hljs"><pre><code>return 3.0*y*y - 2.0*y*y*y; //Return smooth, cubic value</code></pre></span>
                    </div><div class="examples ">
                            <div class="title">Examples:</div>
                            <ul><li><pre><code>//Set the light brightness to 1.0 at the center and fade out to 'radius'
float light = smoothstep(radius, 0.0, dist);</pre></code></li><li><pre><code>//Increase the color contrast by using a narrower range.
color = smoothstep(contrast, 1.0-contrast, color);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="pow">
                    <div class="link" onclick="creacopURL(this, 'pow')">Copy link</div>
                    <div class="content">
                        <div class="name">pow(x, y)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>pow(float/vec, float/vec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">x</div><div class="desc block">
                        <div class="title">Description:</div>
                        The base.
                    </div></li><li><div class="name">y</div><div class="desc block">
                        <div class="title">Description:</div>
                        The exponent.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        float/vec, 'x' to the 'y' power
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Returns x raised to the y power, so <span class="inline-hljs"><pre><code>pow(2.0,3.0) = 2.0*2.0*2.0</code></pre></span> or 8. Make sure your arguments have the same number of dimensions. Raising a vec3 to a float power will cause an error! Also make sure 'x' is not a negative number or it may cause artifacts (typically a black screen).
                    </div><div class="examples ">
                            <div class="title">Examples:</div>
                            <ul><li><pre><code>//Adjust for gamma correction.
vec3 gamma_encode = pow(color.rgb, vec3(2.2));</pre></code></li><li><pre><code>//Make a cool blue gradient using different exponents.
vec3 gradient = pow(uv.yyy, vec3(2.0, 1.0, 0.5))</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="sqrt">
                    <div class="link" onclick="creacopURL(this, 'sqrt')">Copy link</div>
                    <div class="content">
                        <div class="name">sqrt(x)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>sqrt(float/vec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">x</div><div class="desc block">
                        <div class="title">Description:</div>
                        The input value.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        float/vec, square root of x
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Returns the square root of x, just like in GML. Make sure 'x' is not a negative number or it will cause artifacts (typically a black screen).
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Compute sphere heightat the current position, 'pos'.
float sphere_height = sqrt(radius * radius - dot(pos, pos));</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="inversesqrt">
                    <div class="link" onclick="creacopURL(this, 'inversesqrt')">Copy link</div>
                    <div class="content">
                        <div class="name">inversesqrt(x)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>inversesqrt(float/vec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">x</div><div class="desc block">
                        <div class="title">Description:</div>
                        The input value.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        float/vec, one over the square root of x
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Returns the reciprocal of the square root of x (<span class="inline-hljs"><pre><code>1.0 / sqrt(x)</code></pre></span>). Shaders are relatively efficient at computing this so it's better than dividing by sqrt. Make sure 'x' is greater than 0.0 as a value of 0.0 will cause a division-by-zero error.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Compute a weight value from an inverse square-root.
float weight = inversesqrt(i+1.0);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="exp">
                    <div class="link" onclick="creacopURL(this, 'exp')">Copy link</div>
                    <div class="content">
                        <div class="name">exp(x)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>exp(float/vec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">x</div><div class="desc block">
                        <div class="title">Description:</div>
                        The input value.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        float/vec, 'e' to the 'x' power
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Returns <a href='https://en.wikipedia.org/wiki/E_(mathematical_constant)' target='_blank'>Euler's number, 'e'</a> raised to the 'x' power. e has a value of <span class="inline-hljs"><pre><code>2.7182818...</code></pre></span>, which is the exponentation standard because of it's <span title='The derivative of e to the x is itself, e to the x! I just thought I should include this for anyone interested. You can read up on exponent derivatives for more information'>unique properties</span>.<br>This is faster to compute than <a href='/glossary/?load=pow' target='_blank'>pow</a> to compute because it deals with a fixed base.<br>It's also the inverse function of <a href='/glossary/?load=log' target='_blank'>log</a>, meaning <span class="inline-hljs"><pre><code>log(exp(x)) == x</code></pre></span>
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//This compute lighting with an exponentially falloff.
float light = exp(-dist * falloff);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="exp2">
                    <div class="link" onclick="creacopURL(this, 'exp2')">Copy link</div>
                    <div class="content">
                        <div class="name">exp2(x)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>exp2(float/vec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">x</div><div class="desc block">
                        <div class="title">Description:</div>
                        The input value.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        float/vec, 2 to the 'x' power
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Returns 2.0 raised to the 'x' power. So <span class="inline-hljs"><pre><code>exp2(1.0) = 2.0</code></pre></span>, <span class="inline-hljs"><pre><code>exp2(2.0) = 4.0</code></pre></span> and <span class="inline-hljs"><pre><code>exp2(8.0) = 256.0</code></pre></span>. <br>This is faster to compute than <a href='/glossary/?load=pow' target='_blank'>pow</a> to compute because it deals with a fixed base.<br>It's also the inverse function of <a href='/glossary/?load=log2' target='_blank'>log2</a>, meaning <span class="inline-hljs"><pre><code>log2(exp2(x)) == x</code></pre></span>
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//This compute lighting with an exponentially falloff.
float light = exp(-dist * falloff);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="log">
                    <div class="link" onclick="creacopURL(this, 'log')">Copy link</div>
                    <div class="content">
                        <div class="name">log(x)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>log(float/vec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">x</div><div class="desc block">
                        <div class="title">Description:</div>
                        The input value.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        float/vec, base 'e' log of 'x'
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Returns the <a href='https://en.wikipedia.org/wiki/Natural_logarithm' target='_blank'>Natural logarithm</a>. In short, this is the inverse function of <a href='/glossary/?load=exp' target='_blank'>exp</a>, meaning <span class="inline-hljs"><pre><code>log(exp(x)) == x</code></pre></span>.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Smooth maximum based off iq's smin function: https://iquilezles.org/www/articles/smin/smin.htm
float smax = log(exp(a*k)+exp(b*k))/k;</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="log2">
                    <div class="link" onclick="creacopURL(this, 'log2')">Copy link</div>
                    <div class="content">
                        <div class="name">log2(x)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>log2(float/vec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">x</div><div class="desc block">
                        <div class="title">Description:</div>
                        The input value.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        float/vec, base 2 log of 'x'
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Returns the <a href='https://en.wikipedia.org/wiki/Binary_logarithm' target='_blank'>Binary logarithm</a>. In short, this is the inverse function of <a href='/glossary/?load=exp' target='_blank'>exp2</a>, meaning <span class="inline-hljs"><pre><code>log2(exp2(x)) == x</code></pre></span>.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Round x up to a power of 2 number (e.g. 2,4,8...)
float powerOf2 = exp2(ceil(log2(x)));</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="length">
                    <div class="link" onclick="creacopURL(this, 'length')">Copy link</div>
                    <div class="content">
                        <div class="name">length(x)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>length(float/vec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">x</div><div class="desc block">
                        <div class="title">Description:</div>
                        The input value.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        float, length of vector
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Returns the length of a vector by calculating it's <a href='https://en.wikipedia.org/wiki/Hypotenuse' target='_blank'>hypotenuse</a>. It works on any number of dimensions with the float variant behaving like <span class="inline-hljs"><pre><code>abs(x)</code></pre></span><br>This also can be calculated as <span class="inline-hljs"><pre><code>sqrt(dot(x,x))</code></pre></span> so be sure to use <a href='/glossary/?load=dot' target='_blank'>dot</a> instead if you need the distance squared.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Calculate a light's attenuation based the distance to the light
float light = max(1.0 - length(pixel_pos - light_pos) / radius, 0.0);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="distance">
                    <div class="link" onclick="creacopURL(this, 'distance')">Copy link</div>
                    <div class="content">
                        <div class="name">distance(a, b)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>distance(float/vec, float/vec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">a</div><div class="desc block">
                        <div class="title">Description:</div>
                        The starting point.
                    </div></li><li><div class="name">b</div><div class="desc block">
                        <div class="title">Description:</div>
                        The end point.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        float, distance between points
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Returns the distance between two vectors by calculating it's <a href='https://en.wikipedia.org/wiki/Hypotenuse'>hypotenuse</a>. It works on any number of dimensions with the float variant behaving like <span class="inline-hljs"><pre><code>abs(a - b)</code></pre></span><br>This also can be calculated as <span class="inline-hljs"><pre><code>sqrt(dot(a - b, a - b))</code></pre></span> so be sure to use <a href='/glossary/?load=dot'>dot</a> instead if you need the distance squared.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Calculate a light's attenuation based the distance to the light
float light = max(1.0 - distance(pixel_pos, light_pos) / radius, 0.0);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="normalize">
                    <div class="link" onclick="creacopURL(this, 'normalize')">Copy link</div>
                    <div class="content">
                        <div class="name">normalize(x)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>normalize(float/vec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">x</div><div class="desc block">
                        <div class="title">Description:</div>
                        The input value.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        float/vec, 'x' with a length of 1.0
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Returns the vector, divided by it's <a href='/glossary/?load=length' target='_blank'>length</a>, giving it a length of 1.0. In the rare event where the vector has a length of 0.0, it will return all zeros.<br>This is often used for lighting, need to know the direction without the magnitude.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Compute the dot lighting with the light direction
float light_dot = max(dot(normal, normalize(pos - light_pos)), 0.0);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="dot">
                    <div class="link" onclick="creacopURL(this, 'dot')">Copy link</div>
                    <div class="content">
                        <div class="name">dot(a, b)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>dot(float/vec, float/vec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">a</div><div class="desc block">
                        <div class="title">Description:</div>
                        The first vector.
                    </div></li><li><div class="name">b</div><div class="desc block">
                        <div class="title">Description:</div>
                        The second vector.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        float, dot product of 'a' and 'b'
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Returns the sum of the components of <span class="inline-hljs"><pre><code>a * b</code></pre></span>. So if 'a' and 'b' are vec2s then <span class="inline-hljs"><pre><code>dot(a, b) = a.x * b.x + a.y * b.y</code></pre></span>.<br>Dot products have many different uses. If you know both vectors are normalized, then the dot product will be 1.0 if they are pointed in the same direction, 0.0 if perpendicular and -1.0 if opposite along with values in between. You can use <a href='/glossary/?load=acos' target='_blank'>acos</a> on the dot product to find the angle between the two vectors.<br>If one vector is normalized, the dot product tells you how far a vector is along that direction.
                    </div><div class="examples ">
                            <div class="title">Examples:</div>
                            <ul><li><pre><code>//Compute the luminance using a weighted average
float grayscale = dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));</pre></code></li><li><pre><code>//A gradient between a start and end point
vec2 direction = end - start;
float gradient = dot(position - start, direction) / dot(direction, direction);</pre></code></li><li><pre><code>//Compute the dot lighting with the light direction
float light_dot = max(dot(normal, normalize(pos - light_pos)), 0.0);</pre></code></li><li><pre><code>//Compute a pseudo-random hash from 'n'
float hash = fract(sin(dot(n, vec2(4.044,6.536))) * 4101.);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="cross">
                    <div class="link" onclick="creacopURL(this, 'cross')">Copy link</div>
                    <div class="content">
                        <div class="name">cross(a, b)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>cross(vec3, vec3)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">a</div><div class="desc block">
                        <div class="title">Description:</div>
                        The first vector.
                    </div></li><li><div class="name">b</div><div class="desc block">
                        <div class="title">Description:</div>
                        The second vector.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        vec3, cross product of 'a' and 'b'
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Computes the cross product 'a' and 'b' which is always perpendicular to both vectors. If 'a' and 'b' are parallel or opposite or either one is zero, the result will be vec3(0.0). The formula for calculating a cross product is  <span class="inline-hljs"><pre><code>cross(a, b) = a.yzx * b.zxy - a.zxy * b.yzx</code></pre></span>.
                    </div><div class="examples ">
                            <div class="title">Examples:</div>
                            <ul><li><pre><code>//Compute the side vector from the camera forward and up
vec3 side = normalize(cross(forward, up));</pre></code></li><li><pre><code>//Compute the normal from standard derivatives
vec3 normal = normalize(cross(dFdx(pos), dFdy(pos)));</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="reflect">
                    <div class="link" onclick="creacopURL(this, 'reflect')">Copy link</div>
                    <div class="content">
                        <div class="name">reflect(i, n)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>reflect(float/vec, float/vec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">i</div><div class="desc block">
                        <div class="title">Description:</div>
                        The incident vector.
                    </div></li><li><div class="name">n</div><div class="desc block">
                        <div class="title">Description:</div>
                        The normal vector.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        float/vec, reflection of 'i' against 'n'
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Reflects the incidence ('i') vector off of the normal ('n'). You probably want both vectors normalized, otherwise you'll get a non-normalized result. The formula for calculating this reflection is <span class="inline-hljs"><pre><code>i - 2.0 * dot(n, i) * n</code></pre></span>.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Compute the reflection of the viewspace direction and the normal
vec3 reflection_direction = reflect(normalize(view), normal);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="refract">
                    <div class="link" onclick="creacopURL(this, 'refract')">Copy link</div>
                    <div class="content">
                        <div class="name">refract(i, n, r)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>refract(float/vec, float/vec, float)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">i</div><div class="desc block">
                        <div class="title">Description:</div>
                        The incident vector.
                    </div></li><li><div class="name">n</div><div class="desc block">
                        <div class="title">Description:</div>
                        The normal vector.
                    </div></li><li><div class="name">r</div><div class="desc block">
                        <div class="title">Description:</div>
                        The ratio between refraction indices.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        float/vec, refraction ray
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Used to compute the direction of a refracted ray using the angle of incidence ('i'), the normal ('n') and the ratio between the  <a href='https://en.wikipedia.org/wiki/Refraction' target='_blank'>refraction indices</a>. So for example, water has a refractive index of about 1.33 and <span title='It's worth noting that refractive indices do vary with temperature and pressure and are not universal. For example, you'll see refraction in the air around a fire because of the extra heat.>air is 1.0</span> so refracting into water would have a ratio of <span class="inline-hljs"><pre><code>1.0 / 1.33</code></pre></span> and refracting out would be <span class="inline-hljs"><pre><code>1.33 / 1.0</code></pre></span>.<br><br>Note: Make sure both vectors are normalized or the forumla won't work correctly. If you're curious about the forumla, here it is:<br><span class="inline-hljs"><pre><code>float k = 1.0 - r * r * (1.0 - dot(n, i) * dot(n, i));</code></pre></span><br><span class="inline-hljs"><pre><code>(k < 0.0) ? i-i : r * i - (r * dot(n, i) + sqrt(k)) * n;</code></pre></span>
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Compute the refraction vector into water
vec3 refraction_direction = refract(normalize(view), normal, 1.0/1.33);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="faceforward">
                    <div class="link" onclick="creacopURL(this, 'faceforward')">Copy link</div>
                    <div class="content">
                        <div class="name">faceforward(d, i, r)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>faceforward(float/vec, float/vec, float/vec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">d</div><div class="desc block">
                        <div class="title">Description:</div>
                        The input vector.
                    </div></li><li><div class="name">i</div><div class="desc block">
                        <div class="title">Description:</div>
                        The incident vector.
                    </div></li><li><div class="name">r</div><div class="desc block">
                        <div class="title">Description:</div>
                        The reference vector.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        float/vec, 'd' oriented by 'i' and 'r'
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        This flips the value of 'd' depending on if 'i' is facing away from 'r' and does not flip if they're facing the same direction. If I'm being honest, I barely have a use for this.<br><br>Internally, this computed like so:<br><span class="inline-hljs"><pre><code>faceforward(d,i,r) = dot(i, r) < 0.0 ? d : -d;</code></pre></span>
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Flip a random kernel if it's facing against the normal
vec3 hemisphere = faceforward(kernel, kernel, normal)</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="matrixCompMult">
                    <div class="link" onclick="creacopURL(this, 'matrixCompMult')">Copy link</div>
                    <div class="content">
                        <div class="name">matrixCompMult(a, b)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>matrixCompMult(mat, mat)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">a</div><div class="desc block">
                        <div class="title">Description:</div>
                        The first matrix.
                    </div></li><li><div class="name">b</div><div class="desc block">
                        <div class="title">Description:</div>
                        The second matrix.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        mat, component product of 'a' and 'b'
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        This multiplies matrices, 'a' and 'b', component by component and returns the result. So <span class="inline-hljs"><pre><code>a[0,0] * b[0,0]</code></pre></span>, <span class="inline-hljs"><pre><code>a[1,0] * b[1,0]</code></pre></span> and so on. Make sure the matrices have the same dimensions or you'll get an error!
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Compute weights as a component product of 'a' and 'b'
mat4 weights = matrixCompMult(a, b);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="radians">
                    <div class="link" onclick="creacopURL(this, 'radians')">Copy link</div>
                    <div class="content">
                        <div class="name">radians(x)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>radians(float/vec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">x</div><div class="desc block">
                        <div class="title">Description:</div>
                        The input value.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        float/vec, convert 'x' to radians
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Converts 'x' degrees into radians. Degrees range from 0 to 360 and radians range from 0 to <span title='This is pi * 2.0, so it's an irrational number that can be expanded indefinitely. 7 or 8 digits should be sufficient for floats.'>6.2831853</span>. All the Trigonometry functions, like <a href='/glossary/?load=sin' target='_blank'>sin</a> use radians so you may need to use this. <br><br>Internally, this computed like so:<br><span class="inline-hljs"><pre><code>radians(x) = x / 180.0 * 3.1415926;</code></pre></span>
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Convert 60 degree to radians
float sixty = radians(60.0);
//Compute a rotation matrix for this angle
mat2 rotate = mat2(cos(sixty), sin(sixty), -sin(sixty), cos(sixty));</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="degrees">
                    <div class="link" onclick="creacopURL(this, 'degrees')">Copy link</div>
                    <div class="content">
                        <div class="name">degrees(x)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>degrees(float/vec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">x</div><div class="desc block">
                        <div class="title">Description:</div>
                        The input value.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        float/vec, convert 'x' to degrees
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Converts 'x' radians into degrees. Degrees range from 0 to 360 and radians range from 0 to <span title='This is pi * 2.0, so it's an irrational number that can be expanded indefinitely. 7 or 8 digits should be sufficient for floats.'>6.2831853</span>. All the Trigonometry functions, like <a href='/glossary/?load=sin' target='_blank'>sin</a> use radians so you'll probably need to convert back to <a href='/glossary/?load=radians' target='_blank'>radians</a>. <br><br>Internally, this computed like so:<br><span class="inline-hljs"><pre><code>degrees(x) = x / 3.1415926 * 180.0;</code></pre></span>
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Convert pi/2 to degrees (about 90)
float ninety = degrees(1.5707963);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="sin">
                    <div class="link" onclick="creacopURL(this, 'sin')">Copy link</div>
                    <div class="content">
                        <div class="name">sin(x)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>sin(float/vec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">x</div><div class="desc block">
                        <div class="title">Description:</div>
                        The input angle (radians).
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        float/vec, the sine of 'x'
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Computes the <a href='https://en.wikipedia.org/wiki/Sine' target='_blank'>sine</a> of 'x'. It's mostly used to tell you the y-position of a point along a circle's edge at angle 'x' (in radians). Here's an <a href='https://upload.wikimedia.org/wikipedia/commons/thumb/7/72/Sinus_und_Kosinus_am_Einheitskreis_1.svg/1024px-Sinus_und_Kosinus_am_Einheitskreis_1.svg.png' target='_blank'>illustration</a>. It ranges between -1.0 and 1.0 so you can multiply it by the circle's radius to recreate something like 'lengthdir_y' in GML.
                    </div><div class="examples ">
                            <div class="title">Examples:</div>
                            <ul><li><pre><code>//Compute the direction vector from a radian angle
vec2 direction = vec2(cos(angle), sin(angle));</pre></code></li><li><pre><code>//Compute a pseudo-random hash from 'n'
float hash = fract(sin(dot(n, vec2(4.044,6.536))) * 4101.);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="cos">
                    <div class="link" onclick="creacopURL(this, 'cos')">Copy link</div>
                    <div class="content">
                        <div class="name">cos(x)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>cos(float/vec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">x</div><div class="desc block">
                        <div class="title">Description:</div>
                        The input angle (radians).
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        float/vec, the cosine of 'x'
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Computes the <a href='https://en.wikipedia.org/wiki/Cosine' target='_blank'>cosine</a> of 'x'. It's mostly used to tell you the x-position of a point along a circle's edge at angle 'x' (in radians). Here's an <a href='https://upload.wikimedia.org/wikipedia/commons/thumb/7/72/Sinus_und_Kosinus_am_Einheitskreis_1.svg/1024px-Sinus_und_Kosinus_am_Einheitskreis_1.svg.png' target='_blank'>illustration</a>. It ranges between -1.0 and 1.0 so you can multiply it by the circle's radius to recreate something like 'lengthdir_x' in GML.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Compute the direction vector from a radian angle
vec2 direction = vec2(cos(angle), sin(angle));</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="tan">
                    <div class="link" onclick="creacopURL(this, 'tan')">Copy link</div>
                    <div class="content">
                        <div class="name">tan(x)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>tan(float/vec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">x</div><div class="desc block">
                        <div class="title">Description:</div>
                        The input angle (radians).
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        float/vec, the tangent of 'x'
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Computes the <a href='en.wikipedia.org/wiki/Trigonometric_functions' target='_blank'>tangent</a> of 'x'. It's used to tell you the ratio of y/x-position of a point along a circle's edge at angle 'x' (in radians). In otherwords it's the same as <span class="inline-hljs"><pre><code>tan(x) = sin(x) / cos(x)</code></pre></span>. It ranges from negative infinity to positive infinity.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Compute the y/x ratio at 'angle'
float ratio = tan(angle);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="asin">
                    <div class="link" onclick="creacopURL(this, 'asin')">Copy link</div>
                    <div class="content">
                        <div class="name">asin(x)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>asin(float/vec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">x</div><div class="desc block">
                        <div class="title">Description:</div>
                        The input value.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        float/vec, arcsin of 'x'
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Computes the <a href='https://en.wikipedia.org/wiki/Trigonometric_functions#Inverse_functions' target='_blank'>arcsin</a> of 'x'. It's the inverse function of <a href='/glossary/?load=sin' target='_blank'>sin</a> which means that <span class="inline-hljs"><pre><code>asin(sin(x)) = x;</code></pre></span>. Just make sure that 'x' is -1.0, 1.0 or something in between as all other values are return 0.0.<br>asin(x) will only return a value between <span title='Approximately -1.57079632679 to +1.57079632679.'>-pi/2 and pi/2</span>.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Compute angle 'a' for y = sin(a)
float angle = asin(y);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="acos">
                    <div class="link" onclick="creacopURL(this, 'acos')">Copy link</div>
                    <div class="content">
                        <div class="name">acos(x)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>acos(float/vec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">x</div><div class="desc block">
                        <div class="title">Description:</div>
                        The input value.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        float/vec, arccos of 'x'
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Computes the <a href='https://en.wikipedia.org/wiki/Trigonometric_functions#Inverse_functions' target='_blank'>arccos</a> of 'x'. It's the inverse function of <a href='/glossary/?load=cos' target='_blank'>cos</a> which means that <span class="inline-hljs"><pre><code>acos(cos(x)) = x;</code></pre></span>. Just make sure that 'x' is -1.0, 1.0 or something in between as all other values are return 0.0.<br>acos(x) will only return a value between <span title='Approximately 0 to +3.14159265358'>0 and pi</span>.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Compute angle 'a' for x = cos(a)
float angle = acos(x);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="atan">
                    <div class="link" onclick="creacopURL(this, 'atan')">Copy link</div>
                    <div class="content">
                        <div class="name">atan(y, [x])</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>atan(float/vec, [float/vec])</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">y</div><div class="desc block">
                        <div class="title">Description:</div>
                        The ratio of y to x, or just y if using both arguments.
                    </div></li><li><div class="name">x</div><div class="desc block">
                        <div class="title">Description:</div>
                        The optional x argument.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        float/vec, arctan of 'y'
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Computes the <a href='https://en.wikipedia.org/wiki/Trigonometric_functions#Inverse_functions' target='_blank'>arctan</a> of 'y'. It's helpful to think of <span class="inline-hljs"><pre><code>atan</code></pre></span> as the GLSL equivalent of <span class="inline-hljs"><pre><code>point_direction</code></pre></span> in GML, so it can be used to find the angle between two points (in <a href='/glossary/?load=tan' target='_blank'>radians</a>radians</a>) like so: <span class="inline-hljs"><pre><code>atan(y2-y1, x2-x1)</code></pre></span>.<br>It's also approximately the inverse function of <a href='/glossary/?load=tan' target='_blank'>tan</a> which means that <span class="inline-hljs"><pre><code>atan(tan(y)) = y;</code></pre></span>. 'y' can any value between negative infinity and positive infinity.<br>atan(y) will only return a value between <span title='Approximately -1.57079632679 to +1.57079632679.'>-pi/2 and pi/2</span> while atan(y,x) will return a value between <span title='Approximately -3.14159265358 to +3.14159265358.'>-pi and pi</span>.
                    </div><div class="examples ">
                            <div class="title">Examples:</div>
                            <ul><li><pre><code>//Compute angle for the y to x ratio
float angle = atan(y/x);</pre></code></li><li><pre><code>//Compute angle between p1 and p2
float angle2 = atan(p2.y-p1.y, p2.x-p1.x);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="equal">
                    <div class="link" onclick="creacopURL(this, 'equal')">Copy link</div>
                    <div class="content">
                        <div class="name">equal(a, b)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>equal(float/int/vec, float/int/vec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">a</div><div class="desc block">
                        <div class="title">Description:</div>
                        The first input value.
                    </div></li><li><div class="name">b</div><div class="desc block">
                        <div class="title">Description:</div>
                        The second input value.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        bool/bvec, component-wise 'a' equals 'b'
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Returns true if 'a' is equal to 'b'. With vectors it compares each component separately, returning a bvec.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Returns true for each axis that equals 0.0
bvec3 origin = equal(position, vec3(0.0, 0.0, 0.0));</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="notEqual">
                    <div class="link" onclick="creacopURL(this, 'notEqual')">Copy link</div>
                    <div class="content">
                        <div class="name">notEqual(a, b)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>notEqual(float/int/vec, float/int/vec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">a</div><div class="desc block">
                        <div class="title">Description:</div>
                        The first input value.
                    </div></li><li><div class="name">b</div><div class="desc block">
                        <div class="title">Description:</div>
                        The second input value.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        bool/bvec, component-wise 'a' == 'b'
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Returns true if 'a' is NOT equal to 'b'. With vectors it compares each component separately, returning a bvec.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Returns true for each axis that does not equal 0.0
bvec3 origin = notEqual(position, vec3(0.0, 0.0, 0.0));</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="lessThan">
                    <div class="link" onclick="creacopURL(this, 'lessThan')">Copy link</div>
                    <div class="content">
                        <div class="name">lessThan(a, b)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>lessThan(float/int/vec, float/int/vec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">a</div><div class="desc block">
                        <div class="title">Description:</div>
                        The first input value.
                    </div></li><li><div class="name">b</div><div class="desc block">
                        <div class="title">Description:</div>
                        The second input value.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        bool/bvec, component-wise 'a' < 'b'
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Returns true if 'a' is less than 'b'. With vectors it compares each component separately, returning a bvec.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Returns true for each axis that is less than 0.0
bvec3 negative = lessThan(position, vec3(0.0, 0.0, 0.0));</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="lessThanEqual">
                    <div class="link" onclick="creacopURL(this, 'lessThanEqual')">Copy link</div>
                    <div class="content">
                        <div class="name">lessThanEqual(a, b)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>lessThanEqual(float/int/vec, float/int/vec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">a</div><div class="desc block">
                        <div class="title">Description:</div>
                        The first input value.
                    </div></li><li><div class="name">b</div><div class="desc block">
                        <div class="title">Description:</div>
                        The second input value.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        bool/bvec, component-wise 'a' <= 'b'
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Returns true if 'a' is less than or equal to 'b'. With vectors it compares each component separately, returning a bvec.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Returns true if both axis of position are within 10.0 units of 0, 0
bool box = all(lessThanEqual(abs(position.xy), vec2(10.0)));</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="greaterThan">
                    <div class="link" onclick="creacopURL(this, 'greaterThan')">Copy link</div>
                    <div class="content">
                        <div class="name">greaterThan(a, b)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>greaterThan(float/int/vec, float/int/vec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">a</div><div class="desc block">
                        <div class="title">Description:</div>
                        The first input value.
                    </div></li><li><div class="name">b</div><div class="desc block">
                        <div class="title">Description:</div>
                        The second input value.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        bool/bvec, component-wise 'a' > 'b'
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Returns true if 'a' is greater than 'b'. With vectors it compares each component separately, returning a bvec.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Returns true for each axis that is greater than 0.0
bvec3 positive = greaterThan(position, vec3(0.0, 0.0, 0.0));</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="greaterThanEqual">
                    <div class="link" onclick="creacopURL(this, 'greaterThanEqual')">Copy link</div>
                    <div class="content">
                        <div class="name">greaterThanEqual(a, b)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>greaterThanEqual(float/int/vec, float/int/vec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">a</div><div class="desc block">
                        <div class="title">Description:</div>
                        The first input value.
                    </div></li><li><div class="name">b</div><div class="desc block">
                        <div class="title">Description:</div>
                        The second input value.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        bool/bvec, component-wise 'a' >= 'b'
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Returns true if 'a' is greater than or equal to 'b'. With vectors it compares each component separately, returning a bvec.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Returns true if any axis is 10.0 units or more units away from of 0, 0
bool outside = any(greaterThanEqual(abs(position.xy), vec2(10.0)));</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="any">
                    <div class="link" onclick="creacopURL(this, 'any')">Copy link</div>
                    <div class="content">
                        <div class="name">any(x)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>any(bvec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">x</div><div class="desc block">
                        <div class="title">Description:</div>
                        The boolean input value.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        bool, true if any component is true
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Returns true if at least one component of 'x' is true.<br><br>Does not work on bools. It must be used on boolean vectors.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Returns true if any axis is 10.0 units or more units away from of 0, 0
bool outside = any(greaterThanEqual(abs(position.xy), vec2(10.0)));</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="all">
                    <div class="link" onclick="creacopURL(this, 'all')">Copy link</div>
                    <div class="content">
                        <div class="name">all(x)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>all(bvec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">x</div><div class="desc block">
                        <div class="title">Description:</div>
                        The boolean input value.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        bool, true if all components are true
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Returns true only when all components of 'x' are true.<br><br>Does not work on bools. It must be used on boolean vectors.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Returns true if both axis of position are within 10.0 units of 0, 0
bool box = all(lessThanEqual(abs(position.xy), vec2(10.0)));</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Functions doc" id="not">
                    <div class="link" onclick="creacopURL(this, 'not')">Copy link</div>
                    <div class="content">
                        <div class="name">not(x)</div><div class="syntax ">
                        <div class="title">Syntax:</div>
                        <span class="inline-hljs"><pre><code>not(bvec)</code></pre></span>
                    </div><div class="arguments ">
                            <div class="title">Arguments:</div>
                            <ul><li><div class="name">x</div><div class="desc block">
                        <div class="title">Description:</div>
                        The boolean input value.
                    </div></li></ul>
                        </div><div class="returns ">
                        <div class="title">Returns:</div>
                        bvec, component-wise not operator
                    </div><div class="desc block">
                        <div class="title">Description:</div>
                        Returns the inverse of 'x', so true components become false and false becomes true.<br><br>Does not work on bools. It must be used on boolean vectors.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Another way to do notEqual(a, b) in GLSL ES
bvec3 not_equal = not(equal(a, b));</pre></code></li></ul>
                        </div>
                    </div>
                </div><div id="Built-in Variables" class="type-title"><span>Built-in Variables</span></div><div class="Built-in Variables doc" id="gl_Position">
                    <div class="link" onclick="creacopURL(this, 'gl_Position')">Copy link</div>
                    <div class="content">
                        <div class="name">gl_Position</div><div class="desc block">
                        <div class="title">Description:</div>
                        This variable is required in the vertex shader to set vertex position. So with this you have direct control of each vertex's position (useful for effects like shockwaves or water). <br>The make sure to set the value in <span title='Typically by using MATRIX_WORLD_VIEW_PROJECTION. Projection space ranges from -1.0 to +1.0 for the x, y and z coordinates. -1 on the z axis is near clipping plane and +1 is the far clipping plane.'>projection-space</span>.<br><br><strong>Note:</strong> This is a vec4. The w-component is used for all the matrix translations. When in doubt, leave it as 1.0!
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Output the projection-space vertex position
gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * vec4(in_Position, 1.0);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Built-in Variables doc" id="gl_FragColor">
                    <div class="link" onclick="creacopURL(this, 'gl_FragColor')">Copy link</div>
                    <div class="content">
                        <div class="name">gl_FragColor</div><div class="desc block">
                        <div class="title">Description:</div>
                        This is a required vec4 in the fragment shader to sets the pixel's output color and alpha. You should only set this once.<br><br>Note: you can use <a href='/glossary/?load=gl_FragData' target='_blank'>gl_FragData</a> instead of gl_FragColor.
                    </div><div class="examples ">
                            <div class="title">Examples:</div>
                            <ul><li><pre><code>//Output solid white
gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);</pre></code></li><li><pre><code>//Output the base-texture
gl_FragColor = texture2D(gm_BaseTexture, v_vTexcoord);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Built-in Variables doc" id="gl_FragData">
                    <div class="link" onclick="creacopURL(this, 'gl_FragData')">Copy link</div>
                    <div class="content">
                        <div class="name">gl_FragData[]</div><div class="desc block">
                        <div class="title">Description:</div>
                        This is a vec4 array that can be used in the fragment shader to set the pixel's output color and alpha (as a RGBA vec4) instead of <a href='/glossary/?load=gl_FragColor' target='_blank'>gl_FragColor</a>. This is meant to be used for <span title='Multiple Render Targets, which is where one shader outputs up to 4 results to 4 different surfaces. This is used often in deferred rendering (e.g. normal mapping) systems for faster rendering'>MRTs</span> with <span class="inline-hljs"><pre><code>surface_set_target_ext</code></pre></span> however some platforms only support one output. Check out <a href='/glossary/?load=gl_MaxDrawBuffers' target='_blank'>gl_MaxDrawBuffers</a> for the number of supported render targets.
                    </div><div class="examples ">
                            <div class="title">Examples:</div>
                            <ul><li><pre><code>//Output solid white
gl_FragData[0] = vec4(1.0, 1.0, 1.0, 1.0);</pre></code></li><li><pre><code>//Output the base-texture
gl_FragData[0] = texture2D(gm_BaseTexture, v_vTexcoord);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Built-in Variables doc" id="gl_MaxDrawBuffers">
                    <div class="link" onclick="creacopURL(this, 'gl_MaxDrawBuffers')">Copy link</div>
                    <div class="content">
                        <div class="name">gl_MaxDrawBuffers</div><div class="desc block">
                        <div class="title">Description:</div>
                        This is an int for the number of supported <span title='Multiple Render Targets, which is where one shader outputs up to 4 results to 4 different surfaces. This is used often in deferred rendering (e.g. normal mapping) systems for faster rendering'>MRTs</span> on the current platform (e.g. Windows may support 4, while an Android device supports only 1).
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//If supported, output solid white on the second render target
if (gl_MaxDrawBuffers>1) gl_FragData[1] = vec4(1.0);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Built-in Variables doc" id="gl_FragCoord">
                    <div class="link" onclick="creacopURL(this, 'gl_FragCoord')">Copy link</div>
                    <div class="content">
                        <div class="name">gl_FragCoord</div><div class="desc block">
                        <div class="title">Description:</div>
                        This is a read-only vec4 in the fragment shader that contains the fragment/pixel position in the window (relative to the top-left corner). The z-component will always be 0.0 and the w-component is always 1.0
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Get the current 2D pixel position in the window.
vec2 pixel = gl_FragCoord.xy;</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Built-in Variables doc" id="gl_FrontFacing">
                    <div class="link" onclick="creacopURL(this, 'gl_FrontFacing')">Copy link</div>
                    <div class="content">
                        <div class="name">gl_FrontFacing</div><div class="desc block">
                        <div class="title">Description:</div>
                        This is a read-only bool in fragment shader indicating whether or not a triangle is front-facing (true) or back-facing (false).<br><br>Note: If your models are wound clockwise instead of counter-clockwise, you will want to negate the value. This is only useful if you have face culling off so that you can see both sides of a triangle.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Set the front facing triangles to solid white
if (gl_FrontFacing) gl_FragColor = vec4(1.0);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Built-in Variables doc" id="gm_Matrices">
                    <div class="link" onclick="creacopURL(this, 'gm_Matrices')">Copy link</div>
                    <div class="content">
                        <div class="name">gm_Matrices[]</div><div class="desc block">
                        <div class="title">Description:</div>
                        gm_Matrices is an array of matrices with five to choose from:<br><ul><li><strong>MATRIX_VIEW:</strong> Used to orient space with the view. So the x-axis is always left/right on the screen, the y-axis is up and down and positive z is forward. This is often used for fog because you can get the distance relative to the camera. It's also used for screenspace effects such SSAO.</li><li><strong>MATRIX_PROJECTION:</strong> This matrix accounts for aspect ratio, Field Of View and the near/far clipping planes</li><li><strong>MATRIX_WORLD:</strong> This is an extra matrix, intended for any transformations you might need, like scaling, rotating and translating.</li><li><strong>MATRIX_WORLD_VIEW:</strong> Combines world matrix transformations with the view position and orientation.</li><li><strong>MATRIX_WORLD_VIEW_PROJECTION:</strong> Combines world matrix transformations with the view position/orientation and projection perspective.</li></ul>
                    </div><div class="examples ">
                            <div class="title">Examples:</div>
                            <ul><li><pre><code>//Get the world-space position
vec3 world = (gm_Matrices[MATRIX_WORLD] * vec4(in_Position, 1.0)).xyz;</pre></code></li><li><pre><code>//Output the projection-space vertex position
gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * vec4(in_Position, 1.0);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Built-in Variables doc" id="gm_BaseTexture">
                    <div class="link" onclick="creacopURL(this, 'gm_BaseTexture')">Copy link</div>
                    <div class="content">
                        <div class="name">gm_BaseTexture</div><div class="desc block">
                        <div class="title">Description:</div>
                        This is the sampler from whatever you're drawing. For example, if you're drawing a sprite, it will give you the sprite's texture page. It's sometimes useful to put a sprite on a separate texture page. If you need an additional texture, you can always add a uniform sampler2D!
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Sample the base-texture
vec4 tex = texture2D(gm_BaseTexture, v_vTexcoord);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Built-in Variables doc" id="gm_FogStart">
                    <div class="link" onclick="creacopURL(this, 'gm_FogStart')">Copy link</div>
                    <div class="content">
                        <div class="name">gm_FogStart</div><div class="desc block">
                        <div class="title">Description:</div>
                        This is a float for vertex shader containing the fog start distance from <span class="inline-hljs"><pre><code>gpu_set_fog()</code></pre></span>. This can be used with <a href='/glossary/?load=gm_RcpFogRange' target='_blank'>gm_RcpFogRange</a> to compute the fog at the current position.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Calculate the fog amount from the view_space depth
float fog_factor = (view_pos.z - gm_FogStart) * gm_RcpFogRange;</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Built-in Variables doc" id="gm_RcpFogRange">
                    <div class="link" onclick="creacopURL(this, 'gm_RcpFogRange')">Copy link</div>
                    <div class="content">
                        <div class="name">gm_RcpFogRange</div><div class="desc block">
                        <div class="title">Description:</div>
                        This is a float for vertex shader containing the reciprocal of the fog range value from <span class="inline-hljs"><pre><code>gpu_set_fog()</code></pre></span>, computed as <span class="inline-hljs"><pre><code>1.0 / (fog_end - fog_start)</code></pre></span>. This can be used with <a href='/glossary/?load=gm_FogStart' target='_blank'>gm_FogStart</a> to compute the fog at the current position.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Calculate the fog amount from the view_space depth
float fog_factor = (view_pos.z - gm_FogStart) * gm_RcpFogRange;</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Built-in Variables doc" id="gm_VS_FogEnabled">
                    <div class="link" onclick="creacopURL(this, 'gm_VS_FogEnabled')">Copy link</div>
                    <div class="content">
                        <div class="name">gm_VS_FogEnabled</div><div class="desc block">
                        <div class="title">Description:</div>
                        This is a bool for vertex shader telling if the <span class="inline-hljs"><pre><code>gpu_set_fog()</code></pre></span> is enabled. There's a separate bool called <a href='/glossary/?load=gm_PS_FogEnabled' target='_blank'>gm_PS_FogEnabled</a> for the fragment shader.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Checking if the fog (vertex) is enabled
if (gm_VS_FogEnabled)</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Built-in Variables doc" id="gm_PS_FogEnabled">
                    <div class="link" onclick="creacopURL(this, 'gm_PS_FogEnabled')">Copy link</div>
                    <div class="content">
                        <div class="name">gm_PS_FogEnabled</div><div class="desc block">
                        <div class="title">Description:</div>
                        This is a bool for fragment shader telling if the <span class="inline-hljs"><pre><code>gpu_set_fog()</code></pre></span> is enabled. There's a separate bool called <a href='/glossary/?load=gm_VS_FogEnabled' target='_blank'>gm_VS_FogEnabled</a> for the vertex shader.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Checking if the fog (fragment) is enabled
if (gm_PS_FogEnabled)</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Built-in Variables doc" id="gm_FogColour">
                    <div class="link" onclick="creacopURL(this, 'gm_FogColour')">Copy link</div>
                    <div class="content">
                        <div class="name">gm_FogColour</div><div class="desc block">
                        <div class="title">Description:</div>
                        This is a vec4 for fragment shader containing the fog color from <span class="inline-hljs"><pre><code>gpu_set_fog()</code></pre></span>. The alpha channel is always 1.0.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Blend from the texture color to the fog color based on 'fog_factor'
gl_FragColor = mix(tex_color, gm_FogColour, fog_factor);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Built-in Variables doc" id="gm_LightingEnabled">
                    <div class="link" onclick="creacopURL(this, 'gm_LightingEnabled')">Copy link</div>
                    <div class="content">
                        <div class="name">gm_LightingEnabled</div><div class="desc block">
                        <div class="title">Description:</div>
                        This is a bool for vertex shader to check if GM's lighting system is enabled set with <span class="inline-hljs"><pre><code>draw_set_lighting()</code></pre></span>.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Check if the lighting is enabled before
if (gm_LightingEnabled)</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Built-in Variables doc" id="gm_AmbientColour">
                    <div class="link" onclick="creacopURL(this, 'gm_AmbientColour')">Copy link</div>
                    <div class="content">
                        <div class="name">gm_AmbientColour</div><div class="desc block">
                        <div class="title">Description:</div>
                        This is a vec4 for vertex shader to containing the ambient light color from <span class="inline-hljs"><pre><code>draw_light_define_ambient()</code></pre></span>. The alpha-component will always be 1.0.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Initialize 'lighting' with the ambient light color
vec4 lighting = gm_AmbientColour;</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Built-in Variables doc" id="gm_Lights_Direction">
                    <div class="link" onclick="creacopURL(this, 'gm_Lights_Direction')">Copy link</div>
                    <div class="content">
                        <div class="name">gm_Lights_Direction[]</div><div class="desc block">
                        <div class="title">Description:</div>
                        This is a vec4 array for vertex shader to containing the light direction vector set from <span class="inline-hljs"><pre><code>draw_light_define_direction()</code></pre></span>. The w-component is 1.0 if the light is enabled and 0.0 if not. xyz components will always be normalized.<br>This array's size is set by a macro called <span class="inline-hljs"><pre><code>MAX_VS_LIGHTS</code></pre></span> which is hardcoded to 8, so you're limited to 8 lights.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Add directional lights to 'lighting'
lighting += DoDirLight(world_normal, gm_Lights_Direction[i], gm_Lights_Colour[i]);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Built-in Variables doc" id="gm_Lights_PosRange">
                    <div class="link" onclick="creacopURL(this, 'gm_Lights_PosRange')">Copy link</div>
                    <div class="content">
                        <div class="name">gm_Lights_PosRange[]</div><div class="desc block">
                        <div class="title">Description:</div>
                        This is a vec4 array for vertex shader to containing the light position and range set from <span class="inline-hljs"><pre><code>draw_light_define_point()</code></pre></span>. The w-component is the light's range (0.0 if disabled).<br>This array's size is set by a macro called <span class="inline-hljs"><pre><code>MAX_VS_LIGHTS</code></pre></span> which is hardcoded to 8, so you're limited to 8 lights.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Add point lights to 'lighting'
lighting += DoPointLight(world_pos, world_normal, gm_Lights_PosRange[i], gm_Lights_Colour[i]);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Built-in Variables doc" id="gm_Lights_Colour">
                    <div class="link" onclick="creacopURL(this, 'gm_Lights_Colour')">Copy link</div>
                    <div class="content">
                        <div class="name">gm_Lights_Colour[]</div><div class="desc block">
                        <div class="title">Description:</div>
                        This is a vec4 array for vertex shader to containing the light color <span class="inline-hljs"><pre><code>draw_light_define_point()</code></pre></span> or <span class="inline-hljs"><pre><code>draw_light_define_direction()</code></pre></span>. The alpha-component will always be 1.0.<br>This array's size is set by a macro called <span class="inline-hljs"><pre><code>MAX_VS_LIGHTS</code></pre></span> which is hardcoded to 8, so you're limited to 8 lights.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//Add point lights to 'lighting'
lighting += DoPointLight(world_pos, world_normal, gm_Lights_PosRange[i], gm_Lights_Colour[i]);</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Built-in Variables doc" id="gm_AlphaTestEnabled">
                    <div class="link" onclick="creacopURL(this, 'gm_AlphaTestEnabled')">Copy link</div>
                    <div class="content">
                        <div class="name">gm_AlphaTestEnabled</div><div class="desc block">
                        <div class="title">Description:</div>
                        This is a bool for fragment shader telling if alpha testing from <span class="inline-hljs"><pre><code>gpu_set_alphatestenable()</code></pre></span> is enabled. You can also get the alpha test reference from <a href='/glossary/?load=gm_AlphaRefValue' target='_blank'>gm_AlphaRefValue</a>.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//If alpha testing is enabled, discard alpha values below the reference value
if (gm_AlphaTestEnabled && alpha < gm_AlphaRefValue) discard;</pre></code></li></ul>
                        </div>
                    </div>
                </div><div class="Built-in Variables doc" id="gm_AlphaRefValue">
                    <div class="link" onclick="creacopURL(this, 'gm_AlphaRefValue')">Copy link</div>
                    <div class="content">
                        <div class="name">gm_AlphaRefValue</div><div class="desc block">
                        <div class="title">Description:</div>
                        This is a float for fragment shader containing the alpha test reference from <span class="inline-hljs"><pre><code>gpu_set_alphatestref()</code></pre></span>. You can also get the alpha test toggle from <a href='/glossary/?load=gm_AlphaTestEnabled' target='_blank'>gm_AlphaTestEnabled</a>.
                    </div><div class="examples ">
                            <div class="title">Example:</div>
                            <ul><li><pre><code>//If alpha testing is enabled, discard alpha values below the reference value
if (gm_AlphaTestEnabled && alpha < gm_AlphaRefValue) discard;</pre></code></li></ul>
                        </div>
                    </div>
                </div></div>
            <footer><div class="left">&copy; GM Shaders 2025</div><div class="right"> Website developed by <a target="_blank" href="https://TonyStr.net">TonyStr</a></div></footer>
        </div>
        <script>
            initialize();
            glossaryInit();
        </script>
    </body>
</html>
